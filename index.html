<!DOCTYPE html>
<html>
<head>
    <script src="verb.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/verbToThreeConversion.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/threeBasic.js"></script>
    <style> body {  margin: 0; } </style>
</head>
<body>
<script>
	threeSetup();

    var gravity = -9.81;
    var e = 0.99;
    var transformation = function(angle,vector){
        var transformationmatrix = [Math.cos(angle), Math.sin(angle), -Math.sin(angle),Math.cos(angle)];
        var vector_new = [transformationmatrix[0]*vector[0]+transformationmatrix[1]*vector[1],transformationmatrix[2]*vector[0]+transformationmatrix[3]*vector[1],0];
        return vector_new;
    }
    var inv_transformation = function(angle,vector){
        var inv_transformationmatrix = [Math.cos(angle), -Math.sin(angle), Math.sin(angle),Math.cos(angle)];
        var vector_new = [-inv_transformationmatrix[0]*vector[0]-inv_transformationmatrix[1]*vector[1],-inv_transformationmatrix[2]*vector[0]-inv_transformationmatrix[3]*vector[1],0];
        return vector_new;
    }

    //general Nurbs Circle 
    var knotvec_circ = [0,0,0,0.25,0.25,0.5,0.5,0.75,0.75,1,1,1];
    var ptsweights_circ = [1, 0.70710678118, 1, 0.70710678118, 1, 0.70710678118,1,0.70710678118,1];

    //generate obstacle
    
    var p1a = [-5,4,0], p2a = [5,-1,0], p3a = [10,5,0], p4a = [3,10,0], p5a = [-5, 4, 0];
    var ptsa = [p1a, p2a, p3a, p4a, p5a];
    var curve1 = verb.geom.NurbsCurve.byPoints( ptsa, 3 );
    addCurveToScene( curve1.toThreeGeometry() );

    var init = function() {
        //scene.remove(ball1.toThreeGeometry());
        
        //test distance between ball and obstacle
        var center= [ball1.x+ball1.radius,ball1.y+ball1.radius];
        var closestPoint = curve1.closestPoint([center[0],center[1],0])
        var distance = ball1.calcDistance(closestPoint,center);


        if(ball1.calcCollision(distance)==true){
            ball1.calcCollisionConsequences(ball1.generatecurve(),closestPoint);
        }    
    };  
     
    var Ball = function(x, y, mass, radius, speed) {
        return {
            x: x, //lower left corner x
            y: y, //lower left corner y
            mass: mass,
            radius: radius, 
            speed: speed, 
            _create_draw_obj: function( ) {
                var ball_curve_analytic = this.generatecurve();
                var ball_curve_three    = ball_curve_analytic.toThreeGeometry();
                ball_curve_three.material = ball_curve_three.material || new THREE.LineBasicMaterial({ linewidth: 2, color: 0x000000});
                var ball_plot = new THREE.Line(ball_curve_three );
                return ball_plot;
               // addCurveToScene( ball_curve_three );
            },
            _draw: function( ) {
                scene.add(this._create_draw_obj());
               // addCurveToScene( ball_curve_three );
            },
            //remove doesn't work
            //_remove: function(geom, material) {
            //  material = material || new THREE.LineBasicMaterial({ linewidth: 2, color: 0x000000});
            //  var del_obj = new THREE.Line( geom, material )
            //  scene.remove( del_obj );
            //},
            generatecpts: function() {
                var p1b= [this.x,                this.y+this.radius,     0];
                var p2b= [this.x,                this.y,                 0]; 
                var p3b= [this.x+this.radius,    this.y,                 0]; 
                var p4b= [this.x+2*this.radius,  this.y,                 0]; 
                var p5b= [this.x+2*this.radius,  this.y+this.radius,     0]; 
                var p6b= [this.x+2*this.radius,  this.y+2*this.radius,   0]; 
                var p7b= [this.x+this.radius,    this.y+2*this.radius,   0];
                var p8b= [this.x,                this.y+2*this.radius,   0];

                var ptsb= [p1b,p2b, p3b,p4b, p5b,p6b,p7b,p8b,p1b];

                return ptsb;
            },
            generatecurve: function() {
                return verb.geom.NurbsCurve.byKnotsControlPointsWeights(2, knotvec_circ,this.generatecpts() ,ptsweights_circ );
            },
            gravity: function() {
                this.speed[1] = this.speed[1] + gravity*tick;
                this.x=this.x+this.speed[0]*tick
                this.y =this.y+0.5*gravity*Math.pow(tick,2)+this.speed[1]*tick;
            },
            calcDistance: function(closest_point,center) {
                return Math.sqrt(Math.pow((closest_point[0] - center[0]), 2) + Math.pow((closest_point[1] - center[1]), 2));
            },
            //gravity maybe leads to collision between ball and curve
            calcCollision: function(distance) {
                var tolerance =4*this.radius*tick;
                if(distance <= this.radius+tolerance) {
                    return true;
                } else {
                    return false;
                }
            },
            calcCollisionConsequences: function(ball_curve_analytic,closest_point) {
                var param = ball_curve_analytic.closestParam(closest_point);
                var coll_tangent = ball_curve_analytic.tangent(param);
                if(coll_tangent[1]<0 && !(coll_tangent[1]<0)){
                    var normal_tang = [coll_tangent[1]/coll_tangent[0],1]; 
                }else if(coll_tangent[0]<0){
                    var normal_tang = [coll_tangent[1]/coll_tangent[0],-1]; 
                }else{
                    var normal_tang = [-coll_tangent[1]/coll_tangent[0],1]; 
                }
                var norm =Math.sqrt(Math.pow(normal_tang[0],2)+Math.pow(normal_tang[1],2));
                var normalised_normal_tang =[normal_tang[0]/norm,normal_tang[1]/norm];
                var correction = 0.1;
                
                
                //Collision angle:
                var angle_coll = Math.atan(coll_tangent[1]/coll_tangent[0]);
               
                
                //addPointsToScene(normal_tang);
                //addPointsToScene(closest_point);

                var material_line = new THREE.LineBasicMaterial({color: 0xffffff});
                var geometry_line = new THREE.Geometry();
                geometry_line.vertices.push(
                    new THREE.Vector3(closest_point[0],closest_point[1],closest_point[2]),
                    new THREE.Vector3(closest_point[0]-normalised_normal_tang[0],closest_point[1]-normalised_normal_tang[1],closest_point[2]-normalised_normal_tang[2])
                    //new THREE.Vector3( 10, 0, 0 )
                );

                var line = new THREE.Line( geometry_line, material_line );
                scene.add( line );

                console.log(coll_tangent ,normalised_normal_tang);
                //if (Math.abs(2*Math.angle_coll)<0.1){
                //    return;
                //}
                //convert speeds in local,normalised directions
                var trans_speed = transformation(angle_coll,this.speed);


                //calculate new speeds due to collision
                var trans_speed_new= [0,0];

                trans_speed_new[0] = trans_speed[0]-trans_speed[0]*(1+e);
                trans_speed_new[1] = trans_speed[1]*e;
                
                //convert speeds back to global directions
                this.speed = inv_transformation(angle_coll,trans_speed_new);
                
                this.x  = this.x+correction*normalised_normal_tang[0];
                this.y  = this.y+correction*normalised_normal_tang[1];

            }
        };
    }

    var ball1 = new Ball(7.7,3,10,1,[-10,-10]);

    function timestamp() {
        return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
    };
    
    var now, tick, last = timestamp();

    var update = function() {
        ball1.gravity();
    };

    var render_ball = function() {
        ball1._draw();
    };

    function frame() {
        now   = timestamp();
        tick    = (now-last)/10;
        last = now;

        threeRender(tick);
        };


    function threeRender(tick){
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        function render() {
            init(); 
            render_ball();
            //ball1._remove(ball1._create_draw_obj());
            update(tick);
            requestAnimationFrame( render );
            renderer.render( scene, camera );
        }
    render();
    }
        
    frame();

    //buggy
    //function removeCurveFromScene_here(geom, material){
    //    material = material || new THREE.LineBasicMaterial({ linewidth: 2, color: 0x000FFF});
    //    var del_obj = new THREE.Line( geom, material )
    //    scene.remove( del_obj );
    //}
	
</script>

</body>  

</html>