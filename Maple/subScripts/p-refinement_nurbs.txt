#p-refinement-NURBS
#author Alexander Müller
#version 19.11.14
#Algorithmus from The NURBS Book 2ndEd. - Piegl + Tiller, A5.9
#additional weights

degreeElevCurve:=proc(knvec,cp,g,t)

local bw,Nextw,ebw,gw,Qwoldr,Uholdr,st,unique,nQw,nUh,ncp,i,d,bezalfs,bpts,ebpts,Qw,j,a,ub,k,s,den,nh,r,p,m,ph,ph2,inv,mpi,mh,kind,cind,ua,Uh,mult,oldr,b,lbz,rbz,nume,alfs,sav,Nextbpts,first,last,tr,kj,alf,gam,bet:

#Polynomordung aus Knotvektor generieren

p:=0:
for i from 1 while knvec[i]=knvec[i+1] do
	p:=p+1:
od:

#Initialisieren von Laufvariablen

ncp 	:=ColumnDimension(cp):
d 		:=RowDimension(cp):
m 		:=Dimension(knvec):
ph 		:=p+t:
ph2 	:=ph/2:
bezalfs :=Matrix(p+t+1,p+1):
alfs 	:=Vector(p-1):

#HilfsArrays für Kontrollpunkte und Gewichte

bpts	:=Matrix(d,p+1):
bw 		:=Vector(p+1):
Nextbpts:=Matrix(d,p-1):
Nextw 	:=Vector(p-1):
ebpts	:=Matrix(d,p+t+1):
ebw		:=Vector(p+t+1):

#Generiere neuen Knotvektor

unique:=0:
for i from p+2 to m-p-1 do
	if knvec[i]<>knvec[i+1] then
		unique:=unique+1:
	end if:
od:

Uh 		:=Vector(Dimension(knvec)+2*t+unique*t): 	#neuer Knotvektor
nUh 	:=Dimension(Uh):
Qw 		:=Matrix(d,nUh-ph-1): 						#neue Kontrollpunkte
gw 		:=Vector(nUh-ph-1):   						#neue Gewichte
nQw		:=ColumnDimension(Qw):



#Berechnen der Bezier Polynomerhöhungs-Koeffizienten

bezalfs[1,1]      :=1:
bezalfs[ph+1,p+1] :=1:

for i from 1 to ph2 do
	inv:=1/binomial(ph,i):
	mpi:=min(p,i):
	for j from max(0,i-t) to mpi do 
		bezalfs[i+1,j+1]:=inv*binomial(p,j)*binomial(t,i-j):
	od:
od:

for i from ceil(ph2+1) to ph do
	mpi:=min(p,i-1):
	for j from max(0,i-t-1) to mpi do
		bezalfs[i,j+1]:=bezalfs[ph-i+2,p-j+1]:
	od:
od:

mh 	 		:=ph:
kind 		:=ph+2:																				#kind+1
r 	 		:=-1:
a 			:=p+1:																					#a und b um 1 erhöht
b 	 		:=p+2:
cind 		:=1:																		
ua 	       	:=knvec[1]:
Uh[1..ph+1]	:=ua:

for i from 1 to ncp do
    cp[1..d,i] :=cp[1..d,i]*g[i]: 				 #gewichte Kontrollpunkte
od:  

Qw[1..d,1] 	:=cp[1..d,1]:
gw[1]      	:=g[1]:


#Initialisieren des ersten Bezier Elements

bpts:=cp[1..d,1..p+1]: 
bw 	:=g[1..p+1]:

#Große Schleife durch den Knotvektor

while (b<m) do
	i:=b:

	while b<m and knvec[b]=knvec[b+1] do 
		b:=b+1: 
	od:

	mult:=b-i+1:
	mh:=mh+mult+t:
	ub:=knvec[b];
	oldr:=r;
	r:=p-mult;

	#Einfügen des Knots U[b] r-mal

	if oldr>0 then 
		lbz:=floor((oldr+2)/2)+1: 																										
	else
		lbz:=1:																		
	end if:

	if r>0 then
		rbz:=ph-floor((r+1)/2)+1:																
	else 
		rbz:=ph: 																		
	end if:

	# Einfügen des Knots um Bezier Element zu erhalten

	if r>0 then 
		nume:=ub-ua:
		for k from p+1 by -1 to mult+2 do 												#k+1
			alfs[k-mult-1]:= nume/(knvec[a+k-1]-ua):										
		od:

		for j from 1 to r do
		
			sav:=r-j+1:																	#+1	
			s:=mult+j:
			for k from p+1 by -1 to s+1 do 											#k+1 anstatt k
				bpts[1..d,k]:=alfs[k-s]*bpts[1..d,k]+(1-alfs[k-s])*bpts[1..d,k-1]: 	
				bw[k]		:=alfs[k-s]*bw[k]       +(1-alfs[k-s])*bw[k-1]:
			od:

			Nextbpts[1..d,sav]:=bpts[1..d,p+1]:										#p+1 anstatt p
			Nextw   [     sav]:=bw  [     p+1]
		od:

	end if: #Ende der Einfügung des Knots


	#Polynomerhöhung mit Bezier-Koeffienten

	#for i from lbz to ph do 		#langsamer als Matrix Multiplikation				
	#	ebpts[1..d,i]:=0:
	#	ebw  [     i]:=0:
	#	mpi:=min(p,i):
	#	for j from max(0,i-t-1)+1 to mpi+1 do
	#		ebpts[1..d,i]:=ebpts[1..d,i]+bezalfs[i,j]*bpts[1..d,j]:
	#		ebw  [     i]:=ebw  [     i]+bezalfs[i,j]*bw  [     j]:
	#	od:
	#od: 
	
	ebpts[1..d,..]:=0:
	ebw  [     ..]:=0:
	ebpts 	      :=Transpose(bezalfs.Transpose(bpts)):
	ebw           :=bezalfs.bw:
	

	#Polynomerhöhungsende

	#Löschen von u=knvec[a] oldr-mal:

	if oldr>1 then
		first:=kind-2: 
		last:=kind:
		den:=ub-ua:
		bet:=(ub-Uh[kind-1])/den:

		#Knot-Entfernungs-Schleife

		for tr from 1 to oldr-1 do 
			i:=first: j:=last: kj:=j-kind+1:

			while j-i> tr do #loop and compute the new control points for one removal step																	#n
				if i<=cind then
					alf:=(ub-Uh[i])/(ua-Uh[i]):	

					Qw[1..d,i]:=alf*Qw[1..d,i]+(1-alf)*Qw[1..d,i-1]:
					gw[i]     :=alf*gw[     i]+(1-alf)*gw[     i-1]:
				end if:														
				
				if j>= lbz then																									
					if j-tr<=kind-ph+oldr then 
						gam:=(ub-knvec[j-tr])/den:
						ebpts[1..d,kj]:=gam*ebpts[1..d,kj]+(1-gam)*ebpts[1..d,kj+1]:
						ebw  [     kj]:=gam*ebw  [     kj]+(1-gam)*ebw  [     kj+1]:
					else
						ebpts[1..d,kj]:=bet*ebpts[1..d,kj]+(1-bet)*ebpts[1..d,kj+1]:
						ebw  [     kj]:=bet*ebw  [     kj]+(1-bet)*ebw  [     kj+1]:

					end if:														
					i:=i+1: j:=j-1: kj:=kj-1:
				end if:														
				first:=first-1: last:=last+1:
			od:																	
		od:							
	end if:		# Knot-Entfernungs-Schleife zu Ende

	# speichern von u=knvec[a]

	if a<> p+1 then 
		for i from 0 to ph-oldr-1 do
			Uh[kind]:=ua: 
			kind:=kind+1:
		od:
	end if:

	#Speichern der neuen CPs in Qw

	for j from lbz to rbz do 											
		Qw[1..d,cind]:=ebpts[1..d,j]:
		gw[     cind]:=ebw  [     j]:
		cind:=cind+1:
	od:

	#Qw[1..d,cind..cind+(ceil(rbz)-ceil(lbz))]:=ebpts[1..d,floor(lbz)..floor(rbz)]:
	#	cind:=cind+(ceil(rbz)-ceil(lbz)):

	#Vorbereitung des nächsten Durchgangs
	
	if b<m then 
		for j from 1 to r do  										#j+1
			bpts[1..d,j]:=Nextbpts[1..d,j]:
			bw  [     j]:=Nextw   [     j]:
		od:
		for j from r+1 to p+1 do     								#j+1
			bpts[1..d,j]:=cp[1..d,b-p+j-1]:    						#cp+1
			bw  [     j]:=g [     b-p+j-1]:
		od:

		a:=b: b:=b+1:  ua:=ub:
	else #end knot
		Uh[nUh-ph..nUh]:=ub:
	end if:
od:

Qw[1..d,nQw]:=cp[1..d,ncp]:
gw[     nQw]:=g [     ncp]:

for i from 1 to nQw do
    Qw[1..d,i]:=Qw[1..d,i]/gw[i]: 				
od:  

return Uh,Qw,nQw,gw:
		
end proc: