#knotinsertion for NURBS curves
# author Alexander MÃ¼ller
#version 13.11.14
#Algorithmus from The NURBS Book 2ndEd. - Piegl + Tiller, A5.1
#additional Nurbs weights

with(LinearAlgebra):

knotInsCurvew:=proc(knvec::Vector,cp,g::Vector,newknot,r::integer)
	description "h-refinement with knotinsertion r times";

local i,j,s,d,nk,k,ncp,p,L,alpha,knvecnew,cpnew,ncpnew,Rw,gw,gnew:

#get polynomial degree

p:=-1:
for i from 1 while knvec[i]=0 do
	p:=p+1:
od:

if r>p then error "r = %1 needs to be less or equal to p = %d, reduce knotinsertions r",r,p end if:

#Initialize local variables

s:=0: k:=0:
d:=RowDimension(cp):
Rw:=Matrix(d,p+1):
nk:=Dimension(knvec):
ncp:=ColumnDimension(cp):
ncpnew:=ncp+r;
gw:=Vector(p+1):
gnew:=Vector(ncpnew):
knvecnew:=Vector(nk+r):
cpnew:=Matrix(d,Dimension(knvecnew)-p-1):

#find position of the new knot

for i from 1 while k=0 do
	if knvec[i]<= newknot and knvec[i+1]> newknot then
		k:=i:
	end if:
od:

#calculate multiplicity of newknot

if knvec[k]=newknot then
	for i from k by -1 to k-(p-1) do
		if knvec[i-1]=knvec[i] then
			s:=s+1:
		end if:
	od:
end if:

if r+s>p then error "multiplicity s = %1 + knotinsertion r = %2 shouldn't be higher than p = %3, try a smaller r",s,r,p end if:

#new knotvector

knvecnew[1..k]:=knvec[1..k]:
knvecnew[k+1..k+r]:=newknot:
knvecnew[k+r+1..nk+r]:=knvec[k+1..nk]:

#save unaltered controlpoints and weights

cpnew[1..d,1..k-p]:=cp[1..d,1..k-p]:
gnew[1..k-p]:=g[1..k-p]:
cpnew[1..d,k-s+r..ncp+r]:=cp[1..d,k-s..ncp]:
gnew[k-s+r..ncp+r]:=g[k-s..ncp]:
Rw[1..d,1..p-s+1]:=cp[1..d,k-p..k-s]:
gw[1..p-s+1]:=g[k-p..k-s]:

#new control points (insert knot r times)

for j from 1 to r do
	L:=k-p+j:
	for i from 1 to p-j-s+1 do
		alpha:=(newknot-knvec[L+i-1])/(knvec[i+k]-knvec[L+i-1]):
		Rw[1..d,i]:=alpha*Rw[1..d,i+1]*gw[i+1]+(1-alpha)*Rw[1..d,i]*gw[i]:
		gw[i]:=alpha*gw[i+1]+(1-alpha)*gw[i]:
		cpnew[1..d,L]:=Rw[1..d,1]/gw[1]:
		gnew[L]:=gw[1]:
		cpnew[1..d,k+r-j-s]:=Rw[1..d,p-j-s+1]/gw[p-j-s+1]:
		gnew[k+r-j-s]:=gw[p-j-s+1]:
	od:
	for i from L to k-s-2 do
		cpnew[1..d,i+1]:=Rw[1..d,i-L+2]/gw[i-L+2]:
		gnew[i+1]:=gw[i-L+2]:
	od:
od:

return knvecnew,cpnew,ncpnew,gnew:

end proc: